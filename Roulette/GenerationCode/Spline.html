<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<meta name="authoring-tool" content="Adobe_Animate_CC">
<title>Alpha</title>
<!-- write your code here -->
<style>
  #animation_container {
	position:absolute;
	margin:auto;
	left:0;right:0;
	top:0;bottom:0;
  }

  canvas {
  	border: solid;
  }
</style>
<script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>

<script>
	var canvas, stage, exportRoot, anim_container, dom_overlay_container, fnStartAnimation;
	
	function init() {
		canvas = document.getElementById("canvas");
		anim_container = document.getElementById("animation_container");
		dom_overlay_container = document.getElementById("dom_overlay_container");
		handleComplete();

		var ctx = document.querySelector("canvas").getContext("2d"),
		    points = [
		      10, 10,    // x,y pairs
		      100, 50,
		      1000, 1050
		    ],
		    spline = getCurvePoints(points),
		    length = getLength(spline),
		    t = 0,
		    dx = 3;  // number of pixels to move object

		// move along path:
		(function loop() {
		  // make t ping-pong, and clamp t to [0, (length-1)]
		  t += dx;
		  if (t < 0 || t >= length) dx = -dx;
		  t = Math.max(0, Math.min(length - 1, t));

		  // find segment in points which t is inside:
		  var pos = getXY(spline, t, length);

		  // redraw
		  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		  render();

		  // show marker
		  ctx.fillRect(pos.x - 3, pos.y - 3, 6, 6);

		  requestAnimationFrame(loop)
		})();

		function render(points) {
		  ctx.beginPath();
		  ctx.moveTo(spline[0], spline[1]);
		  for(var i = 2; i < spline.length; i+=2)
		    ctx.lineTo(spline[i], spline[i+1]);
		  ctx.stroke()
		}

		function getXY(points, pos, length) {

		  var len = 0, lastLen, i, l = points.length;

		  // find segment
		  for(i = 2; i < l; i += 2) {
		    lastLen = dist(points[i], points[i+1], points[i-2], points[i-1]);

		    len += lastLen;
		    if (pos < len && lastLen) {
		      len -= lastLen;
		      pos -= len;

		      return {
		        x: points[i-2] + (points[i] - points[i-2]) * (pos / lastLen),
		        y: points[i-1] + (points[i+1] - points[i-1]) * (pos / lastLen)
		      }
		    }
		  }

		  return null
		}

		function getLength(points) {
		  for(var len = 0, i = 0, dx, dy; i < points.length - 2; i+=2) {
		    len += dist(points[i+2], points[i+3], points[i], points[i+1])
		  }
		  return len
		}

		function dist(x1, y1, x2, y2) {
		  var dx = x2 - x1,
		      dy = y2 - y1;
		  return Math.sqrt(dx*dx + dy*dy)
		}

		function getCurvePoints(pts, tension, isClosed, numOfSegments) {

		    // use input value if provided, or use a default value   
		    tension = (typeof tension != 'undefined') ? tension : 0.3;
		    isClosed = isClosed ? isClosed : false;
		    numOfSegments = numOfSegments ? numOfSegments : 16;

		    var _pts = [], res = [],    // clone array
		        x, y,           // our x,y coords
		        t1x, t2x, t1y, t2y, // tension vectors
		        c1, c2, c3, c4,     // cardinal points
		        st, t, i;       // steps based on num. of segments

		    // clone array so we don't change the original
		    //
		    _pts = pts.slice(0);

		    // The algorithm require a previous and next point to the actual point array.
		    // Check if we will draw closed or open curve.
		    // If closed, copy end points to beginning and first points to end
		    // If open, duplicate first points to befinning, end points to end
		    if (isClosed) {
		        _pts.unshift(pts[pts.length - 1]);
		        _pts.unshift(pts[pts.length - 2]);
		        _pts.unshift(pts[pts.length - 1]);
		        _pts.unshift(pts[pts.length - 2]);
		        _pts.push(pts[0]);
		        _pts.push(pts[1]);
		    }
		    else {
		        _pts.unshift(pts[1]);   //copy 1. point and insert at beginning
		        _pts.unshift(pts[0]);
		        _pts.push(pts[pts.length - 2]); //copy last point and append
		        _pts.push(pts[pts.length - 1]);
		    }

		    // ok, lets start..

		    // 1. loop goes through point array
		    // 2. loop goes through each segment between the 2 pts + 1e point before and after
		    for (i=2; i < (_pts.length - 4); i+=2) {
		        for (t=0; t <= numOfSegments; t++) {

		            // calc tension vectors
		            t1x = (_pts[i+2] - _pts[i-2]) * tension;
		            t2x = (_pts[i+4] - _pts[i]) * tension;

		            t1y = (_pts[i+3] - _pts[i-1]) * tension;
		            t2y = (_pts[i+5] - _pts[i+1]) * tension;

		            // calc step
		            st = t / numOfSegments;

		            // calc cardinals
		            c1 =   2 * Math.pow(st, 3)  - 3 * Math.pow(st, 2) + 1; 
		            c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2); 
		            c3 =       Math.pow(st, 3)  - 2 * Math.pow(st, 2) + st; 
		            c4 =       Math.pow(st, 3)  -     Math.pow(st, 2);

		            // calc x and y cords with common control vectors
		            x = c1 * _pts[i]    + c2 * _pts[i+2] + c3 * t1x + c4 * t2x;
		            y = c1 * _pts[i+1]  + c2 * _pts[i+3] + c3 * t1y + c4 * t2y;

		            //store points in array
		            res.push(x);
		            res.push(y);

		        }
		    }

		    return res;
		}

	}

	function handleComplete() {
		//This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
		//exportRoot = new lib.Fish_a();
		
		var lib = {};
		lib.properties = {
			width: 640,
			height: 480,
			fps: 30,
			color: "#FFFFFF",
			opacity: 1.00,
			manifest: [],
			preloads: []
		};

		stage = new createjs.Stage(canvas);
		//stage.addChild(exportRoot);
		stage.enableMouseOver();	
		//Registers the "tick" event listener.
		fnStartAnimation = function() {
			createjs.Ticker.setFPS(lib.properties.fps);
			createjs.Ticker.addEventListener("tick", stage);
		}	    
		//Code to support hidpi screens and responsive scaling.
		function makeResponsive(isResp, respDim, isScale, scaleType) {		
			var lastW, lastH, lastS=1;		
			window.addEventListener('resize', resizeCanvas);		
			resizeCanvas();		
			function resizeCanvas() {			
				var w = lib.properties.width, h = lib.properties.height;			
				var iw = window.innerWidth, ih=window.innerHeight;			
				var pRatio = window.devicePixelRatio || 1, xRatio=iw/w, yRatio=ih/h, sRatio=1;			
				if(isResp) {                
					if((respDim=='width'&&lastW==iw) || (respDim=='height'&&lastH==ih)) {                    
						sRatio = lastS;                
					}				
					else if(!isScale) {					
						if(iw<w || ih<h)						
							sRatio = Math.min(xRatio, yRatio);				
					}				
					else if(scaleType==1) {					
						sRatio = Math.min(xRatio, yRatio);				
					}				
					else if(scaleType==2) {					
						sRatio = Math.max(xRatio, yRatio);				
					}			
				}			
				canvas.width = w*pRatio*sRatio;			
				canvas.height = h*pRatio*sRatio;
				canvas.style.width = dom_overlay_container.style.width = anim_container.style.width =  w*sRatio+'px';				
				canvas.style.height = anim_container.style.height = dom_overlay_container.style.height = h*sRatio+'px';
				stage.scaleX = pRatio*sRatio;			
				stage.scaleY = pRatio*sRatio;			
				lastW = iw; lastH = ih; lastS = sRatio;		
			}
		}
		makeResponsive(true,'both',false,2);	
		fnStartAnimation();
	}

</script>
<!-- write your code here -->
</head>
<body onload="init();" style="margin:0px;">
	<div id="animation_container" style="background-color:rgba(255, 255, 255, 1.00); width:640px; height:480px">
		<canvas id="canvas" width="640" height="480" style="position: absolute; display: block; background-color:rgba(255, 255, 255, 1.00);"></canvas>
		<div id="dom_overlay_container" style="pointer-events:none; overflow:hidden; width:640px; height:480px; position: absolute; left: 0px; top: 0px; display: block;">
		</div>
	</div>
</body>
</html>