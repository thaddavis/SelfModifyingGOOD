<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<meta name="authoring-tool" content="Adobe_Animate_CC">
<title>Alpha</title>
<!-- write your code here -->
<style>
  #animation_container {
	position:absolute;
	margin:auto;
	left:0;right:0;
	top:0;bottom:0;
  }

  canvas {
  	border: solid;
  }
</style>
<script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>

<script>
	var canvas, stage, exportRoot, anim_container, dom_overlay_container, fnStartAnimation;
	function init() {
		canvas = document.getElementById("canvas");
		anim_container = document.getElementById("animation_container");
		dom_overlay_container = document.getElementById("dom_overlay_container");
		handleComplete();

		drawPath();
	}

	function drawPath() {
		var points = [
			100, 100,
			200, 200,
			300, 100,
			400, 400,
			460, 300,
			520, 100,
		];

		var spline = getCurvePoints(points);
		var length = getLength(spline);

		for (var i = 0; i <= spline.length-2; i+=2) {
			var c = new createjs.Shape();
 			c.graphics
 				.beginFill("red")
 				.drawCircle(spline[i],spline[i+1],6);
 			
 			var line1 = new createjs.Shape();
			line1.graphics
				.setStrokeStyle(2, "round")
				.beginStroke("#000000")
				.mt(spline[i],spline[i+1])
				.lt(spline[i+2],spline[i+3]);
			stage.addChild(line1);
			
 			stage.addChild(c);
		}


		console.log('spline', spline);
		for (var i = 0 ; i < spline.length - 2 ; i+=2) {
			
			console.log('spline[i]: ', spline[i]);
			console.log('spline[i+2]: ', spline[i+2]);

			console.log('spline[i+1]: ', spline[i+1]);
			console.log('spline[i+3]: ', spline[i+3]);

			var ax = (spline[i] + spline[i+2]) / 2;
			var ay = (spline[i+1] + spline[i+3]) / 2;

			var dx = (spline[i+2] - spline[i]);
			var dy = (spline[i+3] - spline[i+1]);

			// console.log("---");
			// console.log('spline[i+2] - spline[i] : ', spline[i+2] - spline[i]);
			// console.log('spline[i+3] - spline[i+1] : ', spline[i+3] - spline[i+1]);
			// console.log('***');
			// console.log(dx);
			// console.log(dy);
			var slope = -dy/dx;

			console.log('slope', slope);
			
			var factor = 1;

			if (slope=="-Infinity" || slope=="Infinity") {
				
				console.log("YYAAAYYYY");
				var line1 = new createjs.Shape();
				line1.graphics.setStrokeStyle(2, "round").beginStroke("#00FF00").mt(ax,ay)
					.lt(ax + 50, ay);
				stage.addChild(line1);

				var line2 = new createjs.Shape();
				line2.graphics.setStrokeStyle(2, "round").beginStroke("#FF0F00").mt(ax,ay)
					.lt(ax - 50, ay);
				stage.addChild(line2);

			} else if (slope < 0) {
				console.log('negative');
				var line1 = new createjs.Shape();
				line1.graphics.setStrokeStyle(2, "round").beginStroke("#00FF00").mt(ax,ay)
					.lt(ax - (factor * slope), ay + (factor * slope));
				stage.addChild(line1);

				var line2 = new createjs.Shape();
				line2.graphics.setStrokeStyle(2, "round").beginStroke("#FF0F00").mt(ax,ay)
					.lt(ax + (factor * slope), ay - (factor * slope));
				stage.addChild(line2);

			} else if (slope > 0) {
				console.log('positive');
				var line1 = new createjs.Shape();
				line1.graphics.setStrokeStyle(2, "round").beginStroke("#00FF00").mt(ax,ay)
					.lt(ax - (factor * slope), ay - (factor * slope));
				stage.addChild(line1);

				var line2 = new createjs.Shape();
				line2.graphics.setStrokeStyle(2, "round").beginStroke("#FF0F00").mt(ax,ay)
					.lt(ax + (factor * slope), ay + (factor * slope));
				stage.addChild(line2);
				
			} else {

				// var line1 = new createjs.Shape();
				// line1.graphics.setStrokeStyle(2, "round").beginStroke("#00FF00").mt(ax,ay)
				// 	.lt(ax, ay + 50);
				// stage.addChild(line1);

				// var line2 = new createjs.Shape();
				// line2.graphics.setStrokeStyle(2, "round").beginStroke("#FF0F00").mt(ax,ay)
				// 	.lt(ax, ay - 50);
				// stage.addChild(line2);

			}

			
		
		}

		var t = 0;
		var dx = 3;

		// var rect = new createjs.Shape();
		// rect.graphics.setStrokeStyle(2).beginStroke("red").rect(-10,-10, 20, 20);
		// stage.addChild(rect);

		// createjs.Ticker.addEventListener("tick", tick);
		// function tick() { 
			
		// 	//console.log("TICK!!!"); 
		// 	t += dx;
		//   	if (t < 0 || t >= length) dx = -dx;
		//   	t = Math.max(0, Math.min(length - 1, t));

		//   	// find segment in points which t is inside:
		//   	var pos = getXY(spline, t, length);

		//   	// redraw
		//   	//ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		  
		//   	rect.x = pos.x;
		//   	rect.y = pos.y;
			
		// 	// rect.graphics.clear();
		// 	// rect.graphics.setStrokeStyle(2).beginStroke("red").rect(pos.x, pos.y, 100, 100);
			
		// 	// stage.addChild(rect);

		//   	//stage.addChild(rect);

		//   	// show marker
		//   	//ctx.fillRect(pos.x - 3, pos.y - 3, 6, 6);


		//   	// stage.removeAllChildren();
		// 	stage.update();
		
		// }

	}

	function getCurvePoints(pts) {
	    var tension = 0.2;
	    var isClosed = false;
	    var numOfSegments = 2;

	    var _pts = [], res = [],    // clone array
	        x, y,           // our x,y coords
	        t1x, t2x, t1y, t2y, // tension vectors
	        c1, c2, c3, c4,     // cardinal points
	        st, t, i;       // steps based on num. of segments

	    // clone array so we don't change the original
	    //
	    _pts = pts.slice(0);

	    // The algorithm require a previous and next point to the actual point array.
	    // Check if we will draw closed or open curve.
	    // If closed, copy end points to beginning and first points to end
	    // If open, duplicate first points to befinning, end points to end
	    if (isClosed) {
	        _pts.unshift(pts[pts.length - 1]);
	        _pts.unshift(pts[pts.length - 2]);
	        // _pts.unshift(pts[pts.length - 1]);
	        // _pts.unshift(pts[pts.length - 2]);
	        _pts.push(pts[0]);
	        _pts.push(pts[1]);

	        //console.log(_pts);

	    }
	    else {
	        _pts.unshift(pts[1]);   //copy 1. point and insert at beginning
	        _pts.unshift(pts[0]);
	        _pts.push(pts[pts.length - 2]); //copy last point and append
	        _pts.push(pts[pts.length - 1]);


	        console.log('_pts');
	        console.log(_pts);
	    }

	    // ok, lets start..

	    // 1. loop goes through point array
	    // 2. loop goes through each segment between the 2 pts + 1e point before and after
	    for (i=2; i < (_pts.length - 4); i+=2) {
	        
	    	// console.log("outer loop: " + i);

	        for (t=0; t <= numOfSegments; t++) {

	        	// console.log("numOfSegments: " + t);

	            // calc tension vectors
	            t1x = (_pts[i+2] - _pts[i-2]) * tension;
	            t2x = (_pts[i+4] - _pts[i]) * tension;

	            // console.log("t1x", t1x);
	            // console.log("t2x", t2x);

	            t1y = (_pts[i+3] - _pts[i-1]) * tension;
	            t2y = (_pts[i+5] - _pts[i+1]) * tension;

	            // console.log("t1y", t1y);
	            // console.log("t2y", t2y);

	            // calc step
	            st = t / numOfSegments;

	            // console.log('st', st);

	            // calc cardinals
	            c1 =   2 * Math.pow(st, 3)  - 3 * Math.pow(st, 2) + 1; 
	            c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2); 
	            c3 =       Math.pow(st, 3)  - 2 * Math.pow(st, 2) + st; 
	            c4 =       Math.pow(st, 3)  -     Math.pow(st, 2);

	            // calc x and y cords with common control vectors
	            x = c1 * _pts[i]    + c2 * _pts[i+2] + c3 * t1x + c4 * t2x;
	            y = c1 * _pts[i+1]  + c2 * _pts[i+3] + c3 * t1y + c4 * t2y;

	            //store points in array
	            res.push(x);
	            res.push(y);
	        }
	    }

	    return res;
	}

	//spline, t, length
	function getXY(points, pos, length) {

	  var len = 0, lastLen, i, l = points.length;

	  // find segment
	  for(i = 2; i < l; i += 2) {

	  	//console.log(i);

	    lastLen = dist(points[i], points[i+1], points[i-2], points[i-1]);

	    len += lastLen;
	    if (pos < len && lastLen) {
	      len -= lastLen;
	      pos -= len;

	      return {
	        x: points[i-2] + (points[i] - points[i-2]) * (pos / lastLen),
	        y: points[i-1] + (points[i+1] - points[i-1]) * (pos / lastLen)
	      }
	    }
	  }

	  //return null
	}

	function getLength(points) {
	  for (var len = 0, i = 0, dx, dy; i < points.length - 2; i+=2) {
	    len += dist(points[i+2], points[i+3], points[i], points[i+1])
	  }
	  return len
	}

	function dist(x1, y1, x2, y2) {
	  var dx = x2 - x1,
	      dy = y2 - y1;
	  return Math.sqrt(dx*dx + dy*dy)
	}

	function handleComplete() {
		//This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
		//exportRoot = new lib.Fish_a();
		
		var lib = {};
		lib.properties = {
			width: 640,
			height: 480,
			fps: 30,
			color: "#FFFFFF",
			opacity: 1.00,
			manifest: [],
			preloads: []
		};

		stage = new createjs.Stage(canvas);
		//stage.addChild(exportRoot);
		stage.enableMouseOver();	
		//Registers the "tick" event listener.
		fnStartAnimation = function() {
			createjs.Ticker.setFPS(lib.properties.fps);
			createjs.Ticker.addEventListener("tick", stage);
		}	    
		//Code to support hidpi screens and responsive scaling.
		function makeResponsive(isResp, respDim, isScale, scaleType) {		
			var lastW, lastH, lastS=1;		
			window.addEventListener('resize', resizeCanvas);		
			resizeCanvas();		
			function resizeCanvas() {			
				var w = lib.properties.width, h = lib.properties.height;			
				var iw = window.innerWidth, ih=window.innerHeight;			
				var pRatio = window.devicePixelRatio || 1, xRatio=iw/w, yRatio=ih/h, sRatio=1;			
				if(isResp) {                
					if((respDim=='width'&&lastW==iw) || (respDim=='height'&&lastH==ih)) {                    
						sRatio = lastS;                
					}				
					else if(!isScale) {					
						if(iw<w || ih<h)						
							sRatio = Math.min(xRatio, yRatio);				
					}				
					else if(scaleType==1) {					
						sRatio = Math.min(xRatio, yRatio);				
					}				
					else if(scaleType==2) {					
						sRatio = Math.max(xRatio, yRatio);				
					}			
				}			
				canvas.width = w*pRatio*sRatio;			
				canvas.height = h*pRatio*sRatio;
				canvas.style.width = dom_overlay_container.style.width = anim_container.style.width =  w*sRatio+'px';				
				canvas.style.height = anim_container.style.height = dom_overlay_container.style.height = h*sRatio+'px';
				stage.scaleX = pRatio*sRatio;			
				stage.scaleY = pRatio*sRatio;			
				lastW = iw; lastH = ih; lastS = sRatio;		
			}
		}
		makeResponsive(true,'both',false,2);	
		fnStartAnimation();
	}
</script>
<!-- write your code here -->
</head>
<body onload="init();" style="margin:0px;">
	<div id="animation_container" style="background-color:rgba(255, 255, 255, 1.00); width:640px; height:480px">
		<canvas id="canvas" width="640" height="480" style="position: absolute; display: block; background-color:rgba(255, 255, 255, 1.00);"></canvas>
		<div id="dom_overlay_container" style="pointer-events:none; overflow:hidden; width:640px; height:480px; position: absolute; left: 0px; top: 0px; display: block;">
		</div>
	</div>
</body>
</html>